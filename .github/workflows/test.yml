name: Run tests

on:
  workflow_call:
    inputs:
      build_id:
        required: true
        type: string

jobs:
  prepare-boot-jobs:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        machine:
          - iq-8275-evk
          - iq-9075-evk
          - qcm6490-idp
          #- qcs615-ride
          - rb3gen2-core-kit
          #- qcs8300-ride-sx
          - qcs9100-ride-sx
          - rb1-core-kit
          - qcom-armv8a
          #- qcom-armv7a
        distro:
          - name: poky-altcfg
          - name: qcom-distro
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run lava-test-plans
        uses: ./.github/actions/lava-test-plans
        with:
          machine: ${{ matrix.machine }}
          distro_name: ${{ matrix.distro.name }}
          build_id: ${{ inputs.build_id }}
          gh_token: ${{ secrets.GITHUB_TOKEN }}
          prefix: boottest

  prepare-boot-job-list:
    needs: prepare-boot-jobs
    runs-on: ubuntu-latest
    outputs:
      jobmatrix: ${{ steps.listjobs.outputs.jobmatrix }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: 'Download job templates'
        uses: actions/download-artifact@v6
        with:
          pattern: boottest-*

      - name: "List jobs"
        id: listjobs
        uses: ./.github/actions/list-jobs
        with:
          prefix: "boottest"
          build_id: ${{ inputs.build_id }}
          gh_token: ${{ secrets.GITHUB_TOKEN }}

  submit-boot-job:
    needs: prepare-boot-job-list
    runs-on: ubuntu-latest
    continue-on-error: true
    name: Boot ${{ matrix.target.name }}
    strategy:
      matrix: ${{ fromJson(needs.prepare-boot-job-list.outputs.jobmatrix) }}
    steps:
      - name: 'Download job templates'
        uses: actions/download-artifact@v6
        with:
          pattern: boottest-*
      - name: Submit ${{ matrix.target.name }}
        timeout-minutes: 20
        id: submit
        uses: foundriesio/lava-action@v9
        with:
          lava_token: ${{ secrets.LAVA_TOKEN }}
          lava_url: 'lava.infra.foundries.io'
          job_definition: ${{ matrix.target.path }}
          wait_for_job: true
          fail_action_on_failure: true
          fail_action_on_incomplete: true
          save_result_as_artifact: true
          save_job_details: true
#          result_file_name: "${{ env.RESULT_NAME }}"
          result_file_name: "${{ matrix.target.result_file }}"
      - uses: mwasilew/github-action-matrix-outputs-write@v2
        if: always()
        id: out
        with:
          matrix-step-name: ${{ github.job }}
          matrix-key: ${{ matrix.target.name }}
          artifact-name: ${{ matrix.target.name }}
          outputs: |-
            result: ${{ steps.submit.outcome }}

  boot-job-result:
    runs-on: ubuntu-latest
    needs: [submit-boot-job]
    outputs:
      boot_result: "${{ steps.print-boot-result.outputs.boot_result }}"
    steps:
      - uses: cloudposse/github-action-matrix-outputs-read@v1
        id: read
        with:
          matrix-step-name: "submit-boot-job"
      - id: print-boot-result
        name: "Print boot result"
        run: |
          # collapse results of matrix of boot test jobs to a single result
          echo '${{ steps.read.outputs.result }}' | yq
          BOOT_RESULT=$(echo '${{ steps.read.outputs.result }}' | yq '.[] | first (. != "success")')
          if [ -z "$BOOT_RESULT" ]; then
            BOOT_RESULT="success"
          fi
          echo "boot_result=$BOOT_RESULT"
          echo "boot_result=$BOOT_RESULT" >> "$GITHUB_OUTPUT"

  prepare-premerge-jobs:
    needs: boot-job-result
    # run only if boot jobs are successful
    if: ${{ needs.boot-job-result.outputs.boot_result == 'success' }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        machine:
#          - iq-8275-evk
          - iq-9075-evk
#          - qcm6490-idp
#          - qcs615-ride
          - rb3gen2-core-kit
#          - qcs8300-ride-sx
          - qcs9100-ride-sx
          - rb1-core-kit
#          - qcom-armv8a
#          - qcom-armv7a
        distro:
          - name: poky-altcfg
          - name: qcom-distro
    steps:
      - id: print-condition
        name: "Print condition"
        env:
          RESULT: ${{ needs.boot-job-result.outputs.boot_result }}
        run: |
          echo "${RESULT}"

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run lava-test-plans
        uses: ./.github/actions/lava-test-plans
        with:
          machine: ${{ matrix.machine }}
          distro_name: ${{ matrix.distro.name }}
          build_id: ${{ inputs.build_id }}
          gh_token: ${{ secrets.GITHUB_TOKEN }}
          prefix: premerge
          testplan: pre-merge

  prepare-premerge-job-list:
    needs: prepare-premerge-jobs
    runs-on: ubuntu-latest
    outputs:
      jobmatrix: ${{ steps.listjobs.outputs.jobmatrix }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: 'Download job templates'
        uses: actions/download-artifact@v6
        with:
          pattern: premerge-*

      - name: "List jobs"
        id: listjobs
        uses: ./.github/actions/list-jobs
        with:
          prefix: "premerge"
          build_id: ${{ inputs.build_id }}
          gh_token: ${{ secrets.GITHUB_TOKEN }}

  submit-premerge-job:
    needs: prepare-premerge-job-list
    runs-on: ubuntu-latest
    continue-on-error: true
    name: Pre-merge ${{ matrix.target.name }}
    strategy:
      matrix: ${{ fromJson(needs.prepare-premerge-job-list.outputs.jobmatrix) }}
    steps:
      - name: 'Download job templates'
        uses: actions/download-artifact@v6
        with:
          pattern: premerge-*

      - name: Submit ${{ matrix.target.name }}
        timeout-minutes: 20
        uses: foundriesio/lava-action@v9
        with:
          lava_token: ${{ secrets.LAVA_TOKEN }}
          lava_url: 'lava.infra.foundries.io'
          job_definition: ${{ matrix.target.path }}
          wait_for_job: true
          fail_action_on_failure: true
          fail_action_on_incomplete: true
          save_result_as_artifact: true
          save_job_details: true
          result_file_name: "${{ matrix.target.result_file }}"

  publish-test-summary:
    name: "Publish Tests Summary"
    needs: [submit-premerge-job, submit-boot-job]
    if: |
      always()
      && contains(needs.*.result, 'success')
      && !contains(needs.*.result, 'failure')
    runs-on: ubuntu-latest
    permissions:
      checks: write
      pull-requests: write

    steps:
      - name: Download Artifacts
        uses: actions/download-artifact@v6
        with:
          path: artifacts

      - name: "List files"
        run: |
          echo $GITHUB_WORKSPACE
          ls -R $GITHUB_WORKSPACE

      - name: Publish Test Job Details
        run: |
          INPUT=$(for TESTJOB in $(find ${{ github.workspace }} -name "test-job-*.json")
          do
              JOB_ID=$(cat "${TESTJOB}" | jq ".id")
              JOB_URL="https://lava.infra.foundries.io/results/$JOB_ID"
              JOB_DETAILS=$(curl -s "https://lava.infra.foundries.io/api/v0.2/jobs/$JOB_ID/")
              JOB_HEALTH=$(echo "$JOB_DETAILS" | jq -r ".health")
              JOB_STATE=$(echo "$JOB_DETAILS" | jq -r ".state")
              JOB_DEVICE_TYPE=$(echo "$JOB_DETAILS" | jq -r ".requested_device_type")
              if [ "${JOB_STATE}" = "Finished" ] && [ ${JOB_HEALTH} = "Complete" ]; then
                  # get suites and results
                  JOB_SUITES=$(curl -s "https://lava.infra.foundries.io/api/v0.2/jobs/$JOB_ID/suites/")
                  TEST_RESULTS=$(for SUITE in $(echo "$JOB_SUITES" | jq -r -c ".results[]")
                  do
                      SUITE_NAME=$(echo "$SUITE" | jq -r ".name")
                      SUITE_ID=$(echo "$SUITE" | jq -r ".id")
                      SUITE_TESTS=$(curl -s "https://lava.infra.foundries.io/api/v0.2/jobs/$JOB_ID/suites/$SUITE_ID/tests/")
                      if [ "$SUITE_NAME" != "lava" ]; then
                          TEST_NAME=$(echo "$SUITE_TESTS" | jq -r -c ".results[] | .name")
                          TEST_RESULT=$(echo "$SUITE_TESTS" | jq -r -c ".results[] | .result")
                          TEST_URL="${JOB_URL}"
                          TEST_RESULT_OBJ=$(jq --arg url "$TEST_URL" --arg result "$TEST_RESULT" -n -c '$ARGS.named')
                          if [ -n "$TEST_NAME" ]; then
                              jq -n -c --arg key "$TEST_NAME" --argjson value "$TEST_RESULT_OBJ" '$ARGS.named'
                          fi
                      else
                          TEST_NAME="boot"
                          TEST_URL="${JOB_URL}"
                          TEST_RESULT_OBJ=$(jq --arg url "$TEST_URL" --arg result "pass" -n -c '$ARGS.named')
                          jq -n -c --arg key "$TEST_NAME" --argjson value "$TEST_RESULT_OBJ" '$ARGS.named'
                      fi
                  done | jq -s -c --sort-keys 'from_entries')
              fi
              echo "{\"key\": \"$JOB_DEVICE_TYPE\", \"value\": $TEST_RESULTS}" | jq
          # combine entries from boot jobs and pre-merge jobs
          done | jq -s -c 'reduce .[] as $i ({}; .[$i.key] = ((.[$i.key] // {}) + $i.value))')
          echo "$INPUT"
          DEVICES=$(echo "$INPUT" | jq -r 'keys[]' | sort)

          RESULTS=$(echo "$INPUT" | jq -r '.[] | keys[]?' | sort -u)

          # Print header row
          printf "| %s |" "Test"
          printf "| %s |" "Test" >> $GITHUB_STEP_SUMMARY
          for D in $DEVICES; do
            printf " %s |" "$D"
            printf " %s |" "$D" >> $GITHUB_STEP_SUMMARY
          done
          echo
          echo >> $GITHUB_STEP_SUMMARY

          ## Print separator
          printf "| ---- |"
          printf "| ---- |" >> $GITHUB_STEP_SUMMARY
          for _ in $DEVICES; do
            printf " ---- |"
            printf " ---- |" >> $GITHUB_STEP_SUMMARY
          done
          echo
          echo >> $GITHUB_STEP_SUMMARY

          for R in $RESULTS; do
            printf "| %s |" "$R"
            printf "| %s |" "$R" >> $GITHUB_STEP_SUMMARY

            for D in $DEVICES; do
              VALUE=$(echo "$INPUT" | jq -r --arg d "$D" --arg r "$R" '.[$d][$r].result // ""')
              URL=$(echo "$INPUT" | jq -r --arg d "$D" --arg r "$R" '.[$d][$r].url // ""')
              CHECKMARK=":white_check_mark:"
              if [ "${VALUE}" = "fail" ]; then CHECKMARK=":x:"; fi
              if [ "${VALUE}" = "skip" ]; then CHECKMARK=":warning:"; fi
              if [ -z "${VALUE}" ]; then CHECKMARK=":no_entry_sign:"; fi
              printf " %s [%s](%s) |" "$CHECKMARK" "$VALUE" "$URL"
              printf " %s [%s](%s) |" "$CHECKMARK" "$VALUE" "$URL" >> $GITHUB_STEP_SUMMARY
            done
            echo >> $GITHUB_STEP_SUMMARY
          done
          echo "### All jobs summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Job ID | Device | State | Health |" >> $GITHUB_STEP_SUMMARY
          echo "| ---- | ---- | ---- | ---- |" >> $GITHUB_STEP_SUMMARY
          for TESTJOB in $(find ${{ github.workspace }} -name "test-job-*.json")
          do
              JOB_ID=$(cat "${TESTJOB}" | jq ".id")
              JOB_URL="https://lava.infra.foundries.io/results/$JOB_ID"
              JOB_DETAILS=$(curl -s "https://lava.infra.foundries.io/api/v0.2/jobs/$JOB_ID/")
              JOB_HEALTH=$(echo "$JOB_DETAILS" | jq -r ".health")
              JOB_STATE=$(echo "$JOB_DETAILS" | jq -r ".state")
              JOB_DEVICE_TYPE=$(echo "$JOB_DETAILS" | jq -r ".requested_device_type")
              echo "| [$JOB_ID]($JOB_URL) | $JOB_DEVICE_TYPE | $JOB_STATE | $JOB_HEALTH |" >> $GITHUB_STEP_SUMMARY
          done
